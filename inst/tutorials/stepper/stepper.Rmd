---
title: "Stepper"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include = FALSE}
library(learnr)
library(dplyr)
library(flair)
library(reticulate)
library(shinyAce)
library(daff)
library(reactable)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
# custom scripts
source(here::here("R", "utils.R"))
source(here::here("R", "setup-cache.R"))
source(here::here("R", "knitr-hooks.R"))
source(here::here("R", "diffing.R"))
# install knitr hooks
install_knitr_hooks()
home_path <- here::here("inst/tutorials/data_diff/data/")
nba_data_path <- paste0(home_path, "nba.csv")
rnba <- read.csv(nba_data_path)
```

<!-- `r reactable::reactable(matrix())` -->

# nba data

<!-- ## Read data -->

```{python nba_setup}
import pandas as pd
nba = pd.read_csv(r.nba_data_path)
```

<!-- ## Tidy data -->

<!-- ```{python example, exercise.setup="nba_setup"} -->
<!-- column_names = {'Date': 'date', 'Start (ET)': 'start', -->
<!--   'Unamed: 2': 'box', 'Visitor/Neutral': 'away_team', -->
<!--   'PTS': 'away_points', 'Home/Neutral': 'home_team', -->
<!--   'PTS.1': 'home_points', 'Unamed: 7': 'n_ot'} -->

<!-- nba -->
<!-- # nba = ( -->
<!-- (nba.rename(columns=column_names).dropna(thresh=4)[['date', 'away_team', 'away_points', 'home_team', 'home_points']].assign(date=lambda x: pd.to_datetime(x['date'], format='%a, %b %d, %Y')).set_index('date', append=True).rename_axis(["game_id", "date"]).sort_index() -->
<!-- ) -->
<!-- # ) -->
<!-- ``` -->

```{r echo=FALSE}
shiny::fluidPage(
  # shiny::renderText("hello"),
  shiny::column(12, align = "center",
    shiny::fluidRow(shiny::br()),
    shiny::fluidRow(
      reactable::reactableOutput("base_table")
    )
  ),
  shiny::column(12,
    shiny::fluidRow(shiny::br()),
    shiny::htmlOutput("text")
  ),
  shiny::br(),
  shiny::verbatimTextOutput("value"),
  shiny::column(12, align = "center",
      shiny::fluidRow(
        shiny::actionButton("firstLine", label="First", icon = shiny::icon("fast-backward")),
        shiny::actionButton("previousLine", label="Previous", icon = shiny::icon("arrow-left")),
        shiny::actionButton("nextLine", label="Next", icon = shiny::icon("arrow-right")),
        shiny::actionButton("lastLine", label="Last", icon = shiny::icon("fast-forward"))
      )
  ),
  shiny::column(12, align = "center",
    shiny::fluidRow(shiny::br()),
    shiny::fluidRow(
      reactable::reactableOutput("line_table")
    )
  )
)

```


```{r echo=FALSE, context="server", results="asis"}
# current index of code lines
current <- 1
# last line (the last index: TODO do it programmatically)
lastLine <- 1
# hardcoded example for now
# TODO: build this programmatically from another reference chunk?
# e.g. highlight: <span style=\"background-color:#ffff7f\">.set_index('date', append=True)</span>
" nba = (nba.rename(columns=column_names)
    .dropna(thresh=4)
    [['date', 'away_team', 'away_points', 'home_team', 'home_points']]
    .assign(date=lambda x: pd.to_datetime(x['date'], format='%a, %b %d, %Y'))
    .set_index('date', append=True)
    .rename_axis([\"game_id\", \"date\"])
    .sort_index()
  )" -> code
"column_names = {'Date': 'date', 'Start (ET)': 'start',
  'Unamed: 2': 'box', 'Visitor/Neutral': 'away_team',
  'PTS': 'away_points', 'Home/Neutral': 'home_team',
  'PTS.1': 'home_points', 'Unamed: 7': 'n_ot'}" -> setup_code

# TODO: 
# for each relevant line(s):
# - index/indices
# - summary of the action
# - output of the expression so far
base_expr <- "nba"
start_expr <- "nba.rename(columns=column_names)"

generate_df_outputs <- function(code, setup_code = NULL, base_expr = "", start_expr = "") {
  if (!is.null(setup_code)) {
    reticulate::py_run_string(setup_code)
  }
  code_vec <- unlist(strsplit(code, split="\n"))
  code_vec <- purrr::map_chr(code_vec, stringr::str_trim)
  last_index <- length(code_vec) - 1
  range <- 2:last_index
  outputs <- list(reticulate::py_eval(start_expr))
  for (i in range) {
    start_expr <- paste0(start_expr, code_vec[[i]])
    df <- reticulate::py_eval(start_expr, convert=FALSE)
    outputs <- append(outputs, df)
  }
  outputs
  # handle custom indices
  # TODO hold off on the index and explanation bit for now 
  # but revisit when the output stuff can be generated
}

df_outputs <- generate_df_outputs(code, setup_code, start_expr = start_expr)

df_reactable <- function() {
  # first get the raw pandas dataframe
  raw_df <- 
    if (current == lastLine) {
      df_outputs[[current - 1]]
    } else {
      df_outputs[[current]]
    }
  # check if df is a MultiIndex
  is_multi_index <- "pandas.core.indexes.multi.MultiIndex" %in% class(raw_df$index)
  converted_result <- python_df(raw_df)
  if (is_multi_index) {
    show_index <- !identical(converted_result[[1]], rownames(converted_result))
    grp_cols <- group_columns(
      colnames(converted_result), 
      start = ifelse(show_index, 1, 2)
    )
    return(
      reactable::reactable(
        converted_result,
        rownames = show_index,
        compact = TRUE,
        minRows = 8,
        defaultPageSize = 8,
        showPagination = FALSE,
        # height = 300,
        highlight = TRUE,
        bordered = TRUE,
        columns = grp_cols[[1]],
        columnGroups = grp_cols[[2]]
      )
    )
  }
  
  reactable::reactable(
    converted_result, 
    compact = TRUE,
    minRows = 8,
    defaultPageSize = 8,
    showPagination = FALSE,
    # height = 300,
    highlight = TRUE,
    bordered = TRUE,
  )
}

flair_line <- function() {
  # look for the pattern of the current line in code
  pattern <- unlist(strsplit(code, "\n"))[[current]]
  # and flair it
  code <- flair::flair(code, pattern)
  
  # hardcoded example for now
  # TODO: build this programmatically
  shiny::HTML(
    "<br>",
    "<pre>",
    "<code class=\"language-python\">",
    code,
    "</code>",
    "</pre>"
  )
}

# TODO accept the text from either an existing knitr chunk
# first time initialization of the text area
output$text <- shiny::renderUI({
  # Note: for now, length will always just be the initial code rendered in `output$text`
  lastLine <<- length(unlist(strsplit(code, "\n")))
  flair_line()
})

output$base_table <- renderReactable({
  out <- python_df(reticulate::py_eval(base_expr, convert=FALSE))
  reactable::reactable(
    out,
    defaultPageSize = 8,
    minRows = 8,
    showPagination = FALSE,
    # height = 300,
    compact = TRUE,
    highlight = TRUE,
    bordered = TRUE,
  )
})

output$line_table <- renderReactable({
  df_reactable()
})

# handlers for each button
shiny::observeEvent(input$firstLine, {
  if (current > 1) {
    current <<- 1
  }
  message("clicked First button: ", current)
  output$text <-  shiny::renderUI({
    flair_line()
  })
  output$line_table <- renderReactable({
    df_reactable()
  })
})

shiny::observeEvent(input$previousLine, {
  if (current > 1) {
    current <<- current - 1
  }
  message("clicked Previous button: ", current)
  output$text <- shiny::renderUI({
    flair_line()
  })
  output$line_table <- renderReactable({
    df_reactable()
  })
})

shiny::observeEvent(input$nextLine, {
  if (current < lastLine) {
    current <<- current + 1
  }
  message("clicked Next button: ", current)
  output$text <-  shiny::renderUI({
    flair_line()
  })
  output$line_table <- renderReactable({
    df_reactable()
  })
})

shiny::observeEvent(input$lastLine, {
  if (current < lastLine) {
    current <<- lastLine
  }
  message("clicked Last button: ", current)
  output$text <-  shiny::renderUI({
    flair_line()
  })
  output$line_table <- renderReactable({
    df_reactable()
  })
})

```
